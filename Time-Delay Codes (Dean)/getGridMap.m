% AUTHOR: ALEX DEAN
% DATE: 9/7/2020
%
% getGridMap() calculates and plots different color "shadows" for an 
% arrangement of obstacles on a field that predict the status of a vehicle
% with known velocity at a particular location on the field. The color of
% the shadow at a specific location indicates the vehicle's ability to
% avoid hitting an obstacle at a point in time where the vehicle has not
% initiated any avoidance maneuvers (i.e., if the vehicle has a time delay,
% the coast due to the time delay is applied from the point of interest and
% included in the total distance required to perform the manuever). 
%
% Two independent shadows are created, one that represents an area in which
% the vehicle cannot avoid the obstacle by turning (RED), and one that
% represents an area in which the vehicle cannot avoid the obstacle by
% braking (BLUE). The intersection of these shadows (i.e., cannot turn or
% brake to avoid obstacle) is colored GREY. If the vehicle is in a BLUE
% region, it should make the decision to turn. If it is in the RED region,
% it should make the decision to brake. If it is in the GREY region (prior
% to making any decision) it will crash regardless of any actions taken.
% Note that these regions are not strictly "no-go" regions. If a decision
% is made to avoid the obstacle prior to entering a region, the vehicle may
% enter the region during the course of the manuever.
%
% The no-brake (BLUE) region is generated by calculating the distance
% required for the vehicle to come to a complete stop at its given speed
% and "dragging" each obstacle toward the vehicle that distance along the
% vehicles velocity vector.
%
% The no-turn (RED) region is generated by modeling a very simple turn
% manuever that assumes lateral movement is independent from axial movement
% (i.e., the vehicle has lateral "thrusters" that allow it to accelerate
% laterally without changing the axial velocity vector). The code
% implements a more complicated (and more accurate) method of determining
% the no-turn region than the similar getPolarSweep() code. getGridMap()
% takes all the exposed vertices of an object into account, and allows for
% the possibility that a vehicle can theoretically avoid all the vertices
% of the obstacle, but still hit an obstacle edge.
%
% Note: This code uses degrees for angles. Other units are assumed to be
% meters and seconds; however, any consistent set of units may be used.
%
% RETURNS:
%
% gridMap
% An NxN 2D array, where N is the mesh size of the grid. Each entry
% specifies the status (i.e., color) of the location on the field that
% corresponds to that cell of the grid. The possible values are:
%      - WHITE (1): In the clear (no potential for hitting an obstacle) 
%      - BLACK (2): Inside the obstacle
%      - GREY  (3): Cannot avoid obstacle (crash region)
%      - RED   (4): Must brake to avoid obstacle (no-turn region)
%      - BLUE  (5): Must turn to avoid obstacle (no-brake region)
%
% INPUTS:
%
% field
% A structure representing the field/obstacle characteristic with the
% following fields:
%
% size - The length of one side of the square field
%
% N - The number of grid cells to create along one side (# cells = N^2)
%
% obstacles - A cell array containing a series of rx2 2D arrays, where r 
% (number of rows) is the number of vertices in the obstacle (polytope). 
% Each row consists of the [x,y] coordinates of one vertex. The vertices 
% MUST be provided in a Counter-Clockwise order. The polytope is closed 
% automatically, sich that the first vertex should NOT be repeated at the 
% end of the array. An example of a 10 by 20 meter rectangle with the lower
% left vertex at [75, 40] is shown below:
%
% [  75, 40;
%    85, 40;
%    85, 60;
%    75, 60  ]
%
% Each entry in the cell array is a different obstacle.
%
% vehicle
% A structure representing the vehicle/road characteristics with the 
% following fields:
%
% v - The velocity vector [x,y] that defines both the magnitude and
% direction of the vehicle's nominal motion.
%
% f - The coefficient of friction between the vehicle and the driving
% surface that limits the vehicle's acceleration.
%
% g - The acceleration of gravity (max vehicle acceleration = f*g)
%
% tau - The vehicle time delay in acting on information. This code
% considers a vehicle at a moment in time when a decision has been made to
% execute some maneuver. However, the vehicle does not begin executing that
% maneuver until the time delay has passed. Therefore, a coasting distance,
% where the vehicle continues to travel along its previous trajectory for
% the duration of the time delay, is tacked onto all manuevers.
%
% dtheta - An angular uncertainty in the trajectory of the vehicle (in
% degrees). The velocity vector provides a nominal trajectory for the
% vehicle; however, it may be useful to generate obstacle maps that take
% into account the posibility for the vehicle to deviate from its nominal
% path prior to encountering each obstacle. This input causes the code to
% consider a range of potential trajectories. dtheta is measured from the
% nominal trajectory, such that the total range considered is [nominal -
% dtheta, nominal + dtheta]. The total angular range is therefore 2*dtheta.
%
% loc - The vertex location [x,y] of the vehicle. If this input is left 
% empty, the code will calculate the shadow status at all points on the 
% grid (and output a plot). If a vertex location [x,y] is provided, only a 
% single integer is output indicating the status at the location provided.
% This mode of the code runs faster, since no grid is needed. 
%
% TIPS FOR READING:
%
% - The variables used in this code refer to a vehicle-centric coordinate
% system, where 's' refers to the direction the vehicle is traveling in,
% and 'p' refers to a direction to the vehicle's right (i.e., the vehicle's
% driver's right). 

%%
% This is the base function to be called by the user. This function 
% executes high-level logic, calls other functions to perform each step 
% of the calculation, and plots the output. Inputs and outputs are 
% discussed in detail above.
function gridMap = getGridMap(field, vehicle)

    % Set up color map
    cmap = [1, 1, 1;  0, 0, 0; 0.5, 0.5, 0.5; 1, 0, 0; 0, 0, 1]; % RGB values that correspond to the colors below in order
    color_clear = 1;   % White
    color_obst = 2;    % Black
    color_crash = 3;   % Grey
    color_noTurn = 4;  % Red
    color_noBrake = 5; % Blue
    
    % Set global vars (constants). Any variable that is set as global is
    % meant to be constant and will not be changed in other locations
    % within the code. All globals are set within this function. Function
    % also initializes the output matrix to the correct size.
    gridMap = setGlobalConsts(field, vehicle);
    
    % Set all entries in gridMap to WHITE
    gridMap = gridMap.*color_clear;

    % Initialize trackers. These are logical matrices that will indicated
    % whether each cell in the grid is (1) within an obstacle, (2) within a
    % no-brake zone, and/or (3) within a no-turn zone. Assembling these
    % matrices is the main challenge of this code.
    obstRegion = false(size(gridMap));
    noBrakeRegion = false(size(gridMap));
    noTurnRegion = false(size(gridMap));

    % Add regions for each obstacle
    for nn = 1:length(field.obstacles)
        
        % Each obstacle on its own creates each of the 3 regions of
        % interest. This function extracts them for a single obstcle.
        [obstRegion_obst, noBrakeRegion_obst, noTurnRegion_obst] = ...
            getObstRegions(field.obstacles{nn});
        
        % The final regions are equal to unions of each obstacle-specific
        % region.
        obstRegion = obstRegion | obstRegion_obst;
        noBrakeRegion = noBrakeRegion | noBrakeRegion_obst;
        noTurnRegion = noTurnRegion | noTurnRegion_obst; 
    end

    % Color grid. This is done in a specific order to ensure the GREY
    % region takes precedence over the RED and BLUE regions, and that the
    % BLACK region take precedence over all.
    gridMap(noBrakeRegion) = color_noBrake;              % BLUE
    gridMap(noTurnRegion) = color_noTurn;                % RED
    gridMap(noTurnRegion & noBrakeRegion) = color_crash; % GREY
    gridMap(obstRegion) = color_obst;                    % BLACK

    % Plot output (if a specific location was not provided)
    if isempty(vehicle.loc)
        figure
        hold on
        image(gridMap(end:-1:1,:));      % Plots image by pixel
        colormap(cmap);      % Colors pixels according to predefined color map
        
        % X and Y axes are scaled by number of pixels. Print a label to
        % tell the user what that corresponds to in length.
        xlabel(sprintf("Scale: $%i=%i$ meters", field.N, field.size), "interpreter", "latex")
        
        % Format title
        title_str_1 = "\textbf{Obstacle Shadows}";
        title_str_2 = sprintf("$\\vec{v_0}=\\langle%0.2f, %0.2f\\rangle$ $m/s$, $f=%0.1f$, $\\tau=%0.1f$ $s$, $\\pm%0.0f^{\\circ}$", ...
            vehicle.v(1), vehicle.v(2), vehicle.f, vehicle.tau, vehicle.dtheta);
        title_str = sprintf('\\begin{tabular}{c} %s %s %s \\end{tabular}',title_str_1,'\\',title_str_2);
        title(title_str, ...
            "fontsize", 16, "interpreter", "latex")
        
        % Plot dummy lines for a legend
        plot([-1 -0.5], [-1 -0.5], 'k')
        plot([-1 -0.5], [-1 -0.5], 'r')
        plot([-1 -0.5], [-1 -0.5], 'b')
        plot([-1 -0.5], [-1 -0.5], 'color', [0.5 0.5 0.5])
        legend("Obstacle", "No-Turn", "No-Brake", "Crash Zone")
        
        xlim([0 field.N])
        ylim([0 field.N])
    end
end

%%
% This function sets the global constants used in other functions. These
% constants should not be changed anywhere else in the program.
%
% RETURNS:
%
% gridMap - Initialized form of the program output, filled with ones and 
% the correct size (array for "Map" mode of code, single integer for 
% "Location" mode of code).
%
% INPUTS:
%
% field - discussed above
%
% vehicle - discssused above
function gridMap = setGlobalConsts(field, vehicle)

    % These are the global variables to be set by the function. As other
    % functions use the variables, they will be declared constant within
    % those functions as well.
    global grid_x grid_y               % Array of X and Y coordinates for grid
    global v0 f g tau                  % Extracted vehicle data
    global dtheta                      % Angular uncertainty
    global s_brake                     % Braking distance
    global s_hat0 s_hat_min s_hat_max  % Nominal, minimum, and maximum vehicle trajectories
    global p_hat_min p_hat_max         % Lateral (right-turn) vectors corresponding to min and max trajectories
    
    % Grid coordinates (if specific location is given, "grid" only 
    % consists of that point
    if isempty(vehicle.loc)
        
        % Set up grid
        grid_size = field.size./field.N; % Length of each cell
        gridMap = ones(field.N,field.N);
        
        % Coordinants in center of each cell along field length
        cent_vec = linspace(grid_size./2, field.size - (grid_size./2), field.N);
        grid_x = repmat(cent_vec, field.N, 1); % Repeat rows from 0 (left) to size (right)
        grid_y = repmat(cent_vec(end:-1:1)', 1, field.N); % Repeate columns from size (top) to 0 (bottom)
    else
        % Specific location provided (no real grid)
        grid_x = vehicle.loc(1);
        grid_y = vehicle.loc(2);
        gridMap = 1;
    end

    % Vehicle parameters (extract from vehicle struct)
    v0 = norm(vehicle.v);    % Speed
    f = vehicle.f;           % Coefficient of friction
    g = vehicle.g;           % Acceleration of gravity
    tau = vehicle.tau;       % Time delay
    dtheta = vehicle.dtheta; % Angular uncertainty
    
    % Distance required to brake. This is the sum of the distance traveled
    % during the time delay, and the distance traveled during the
    % decelleration (acc = -f*g, max force obtained out of the wheels)
    s_brake = (v0.*tau) + (0.5.*(v0.^2)./(f.*g));
    
    % Nominal axial unit vector
    s_hat0 = vehicle.v./v0;

    % If there is an angular uncertainty, the maximum and minimum axial and
    % lateral vectors must be set
    if (dtheta > 0)
        % Minimum angle unit vectors (+ theta is CCW)
        s_hat_min = s_hat0*[cosd(-dtheta) sind(-dtheta); -sind(-dtheta) cosd(-dtheta)];
        p_hat_min = cross([s_hat_min 0], [0 0 1]);  
        p_hat_min = p_hat_min(1:2); % Lateral unit vector (right turn)

        % Maximum angle unit vectors
        s_hat_max = s_hat0*[cosd(dtheta) sind(dtheta); -sind(dtheta) cosd(dtheta)];
        p_hat_max = cross([s_hat_max 0], [0 0 1]);
        p_hat_max = p_hat_max(1:2);
    else
        
        % No angular uncertainty. Since most of the rest of the code only
        % considers the maximum and minimum trajectories (and not the
        % nominal), set minimum to be equal to nominal (and ignore max)
        s_hat_min = s_hat0;
        p_hat_min = cross([s_hat_min 0], [0 0 1]);
        p_hat_min = p_hat_min(1:2); % Lateral unit vector
    end
end

%%
% This function finds the 3 regions of interest for one obstacle.
%
% RETURN:
%
% obstRegion - Logical matrix representing the cells containing the obstacle
%
% noBrakeRegion - Logical matrix representing the no-brake region for the obstacle
%
% noTurnRegion - Logical matrix representing the no-turn region for the obstacle
%
% INPUTS:
%
% obstacle - discussed above
function [obstRegion, noBrakeRegion, noTurnRegion] = getObstRegions(obstacle)
    global grid_x
    global dtheta
    
    % The calculation of obstRegion and noBrakeRegion are straight forward.
    % noTurnRegion, however, is somewhat convoluted. When there is no
    % angular uncertainty, the region is simply calculated for the given
    % direction (accounting for the possibility of hitting any obstacle
    % vertex or wall). 
    %
    % When there is an angular uncertainty, the region is
    % assembled from two components: a bounding region that captures the
    % shape of the region at its extreme angular limits (the "left" and
    % "right" boundaries), and a list of "peaks" in polar coordinates that
    % are used to draw a piecewise polar curve forming the radial boundary
    % of the region (i.e., how far away from the obstacle does the region
    % start for a given angle in-between the two extremes).
    %
    % The bounding region is stored as a logical matrix, and the peaks are 
    % stored as an array of polar coordinates. The peaks come from two 
    % places: they are formed from the single-angle no-turn regions at the 
    % two angle extremes, and they are formed from a trajectory within the 
    % angle limits that is normal to an edge of the obstacle. These peaks 
    % should give a resonable approximation to how the region looks between
    % the two extreme angles, however it is an approximation.
    %
    % One area of potential confusion is that the no-turn condition at the
    % minimum and maximum angles are evaluated two different ways, one for
    % the purpose of drawing the "bounding" region, and one for the purpose
    % of finding the two extreme peak locations. The "bounding" region only
    % considers a left turn for the minimum angle and a right turn for the
    % maximum, since these conditions will form the boundaries of the total
    % no-turn region. There are a few subtle differences in how these two
    % calculations are done (despite seeming similar) such that one
    % calculation cannot be done to serve both purposes (or at least I
    % didn't figure out a way to).
    
    % Calculate centroid of obstacle
    [Cx, Cy] = fcn_polytope_calculation_centroid_and_area([obstacle(:,1); obstacle(1,1)], [obstacle(:,2); obstacle(1,2)]);
    obst_cent = [Cx, Cy];
    
    % Init matrices used to store data for each line of the obstacle. For
    % obstRegion, areas of the grid are progressively excluded (so it
    % starts as true. For the others, areas are progressively included (so
    % they start as false).
    obstRegion = true(size(grid_x));   
    noBrakeRegion = false(size(grid_x));
    noRightTurnRegion_min = false(size(grid_x)); % One side of no turn region for min angle
    noLeftTurnRegion_min = false(size(grid_x));  % One side of no turn region for min angle
    
    % If there is angular uncertainty, init logical matrices for tracking
    % the no-turn region for the maximum angle, as well as two additional
    % matrices that help draw the borders of the combined no-turn region,
    % and two more that track the regions "behind" the obstacle (used in
    % conjuction with the bounding matrices to get the right shape).
    if (dtheta > 0)
        noRightTurnRegion_max = false(size(grid_x)); % One side of no turn region for max angle
        noLeftTurnRegion_max = false(size(grid_x));  % One side of no turn region for max angle
        noTurnBound_min = false(size(grid_x));       % Used to draw min boundary of rotated no turn shadow
        noTurnBound_max = false(size(grid_x));       % Used to draw max boundary of rotated no turn shadow
        behindRegion_min = false(size(grid_x));      % Used to track regions behind obst when dtheta <= 90
        behindRegion_max = false(size(grid_x));      % Used to track regions behind obst when dtheta <= 90
    end
    
    turn_peaks = [];  % Stores peak locations used to draw radial boundary
    
    
    % Add regions for each line of obstacle. Each line/vertex of the
    % obstacle will contribute to the overall shadows of the obstacle.
    for ii = 1:size(obstacle,1)

        % Grab vertices for line
        vertex1 = obstacle(ii,:);
        if ii == size(obstacle,1)
            vertex2 = obstacle(1,:);
        else
            vertex2 = obstacle(ii+1,:);
        end

        % Vectors/quantities used to characterize obstacle line
        v1_to_v2 = vertex2 - vertex1;
        line_length = norm(v1_to_v2);
        line_hat = v1_to_v2./line_length;  % Unit vector for obstacle line
        insideVec = cross([line_hat, 0], [0, 0, -1]); % Points to the inside of the obstacle (will be wrong if points aren't in CCW order)

        % Get regions for the line (and peak, if valid)
        % There are 10 different line regions here that are used to
        % assemble the 3 obstacle regions of interest.
        [obstRegion_line, noBrakeRegion_line,...
          noRightTurnRegion_min_line, noRightTurnRegion_max_line, ...
          noLeftTurnRegion_min_line, noLeftTurnRegion_max_line, ...
          noTurnBound_min_line, noTurnBound_max_line, ...
          behindRegion_min_line, behindRegion_max_line, peak] = ...
                                 getLineRegions(vertex1, vertex2, line_hat, line_length, ...
                                                    insideVec, obst_cent);
        
        % Add line regions to obstacle regions
        
        % A point that is on the "inside" direction of all lines of the
        % obstacle is inside the obstacle
        obstRegion = obstRegion & obstRegion_line;
        
        % The vehicle has to be able to avoid all the lines to avoid the
        % obstacle itself, so the danger zones of each line are 'ORed'.
        noBrakeRegion = noBrakeRegion | noBrakeRegion_line;
        noRightTurnRegion_min = noRightTurnRegion_min | noRightTurnRegion_min_line;
        noLeftTurnRegion_min = noLeftTurnRegion_min | noLeftTurnRegion_min_line;
        
        % If there is an angular uncertainty, include these other regions
        % that are used to assemble the rotated/swept no-turn region
        if (dtheta > 0)
            noRightTurnRegion_max = noRightTurnRegion_max | noRightTurnRegion_max_line;
            noLeftTurnRegion_max = noLeftTurnRegion_max | noLeftTurnRegion_max_line;
            noTurnBound_min = noTurnBound_min | noTurnBound_min_line;
            noTurnBound_max = noTurnBound_max | noTurnBound_max_line;
            behindRegion_min = behindRegion_min | behindRegion_min_line;
            behindRegion_max = behindRegion_max | behindRegion_max_line;
            turn_peaks = [turn_peaks; peak];
        end
    end

    % Assemble complete no turn region for obstacle
    if (dtheta > 0)
        [noTurnRegion] = assembleNoTurnRegion(noRightTurnRegion_min, noRightTurnRegion_max, ...
                                 noLeftTurnRegion_min, noLeftTurnRegion_max, ...
                                 noTurnBound_min, noTurnBound_max, ...
                                 behindRegion_min, behindRegion_max, ...
                                 obst_cent, turn_peaks);
    else
        % No angular uncertainty, No-turn region is simply the region where
        % the vehicle cannot make a left or right turn to avoid the
        % obstacle.
        noTurnRegion = noRightTurnRegion_min & noLeftTurnRegion_min;
    end
end

%%
% This function finds the 10 regions of interest of one line, and the
% normal peak location for the line (if it exists within bounds)
%
% RETURN:
%
% obstRegion - Region on the "inside" side of the line
%
% noBrakeRegion - No-brake region for the line
%
% noRightTurnRegion_min - Region where the vehicle, at its minimum
% trajectory, cannot avoid both vertices of the line by making a right
% turn. Used to find min peak.
%
% noRightTurnRegion_max - Region where the vehicle, at its maximum
% trajectory, cannot avoid both vertices of the line by making a right
% turn. Used to find max peak.
%
% noLeftTurnRegion_min - Region where the vehicle, at its minimum
% trajectory, cannot avoid both vertices of the line by making a left
% turn. Used to find min peak.
%
% noLeftTurnRegion_max - Region where the vehicle, at its maximum
% trajectory, cannot avoid both vertices of the line by making a left
% turn. Used to find max peak.
%
% noTurnBound_min - Region forming minimum angle boundary, assuming this is
% the left most line relative to the vehicle (it will be bounded by another
% line region if not). This region will be similar to noLeftTurnRegion_min,
% but not exactly the same.
%
% noTurnBound_max - Region forming maximum angle boundary, assuming this is
% the right most line relative to the vehicle (it will be bounded by another
% line region if not). This region will be similar to noRightTurnRegion_max,
% but not exactly the same.
%
% behindRegion_min - Region that exists behind the obstacle line from the
% perspective of the vehicle traveling at the minimum trajectory. This is
% used to modify the bounding regions when dtheta < 90 to ensure areas
% behind the obstacle are not included in the no turn region.
%
% behindRegion_max - Region that exists behind the obstacle line from the
% perspective of the vehicle traveling at the maximum trajectory. This is
% used to modify the bounding regions when dtheta < 90 to ensure areas
% behind the obstacle are not included in the no turn region.
%
% peak - Location of the peak of a no-turn region for a vehicle trajectory
% that is normal to the obstacle line. This is only output if the normal
% trajectory is within the angular uncertainty of the vehicle. The peak is
% given in polar coordinates [theta, r] relative to the centroid of the
% obstracle.
%
% INPUTS:
%
% vertex1/2 - the two vertices [x,y] that form the line. v2 is CCW from v1.
%
% line_hat - unit vector from vertex1 to vertex2
%
% line_length - the length of the line between the vertices
%
% insideVec - unit vector normal to the line and pointing toward the inside
% of the obstacle
%
% obst_cent - vertex [x,y] of the centroid of the obstacle
function [obstRegion, noBrakeRegion,...
          noRightTurnRegion_min, noRightTurnRegion_max, ...
          noLeftTurnRegion_min, noLeftTurnRegion_max, ...
          noTurnBound_min, noTurnBound_max, ...
          behindRegion_min, behindRegion_max, peak] = ...
                                 getLineRegions(vertex1, vertex2, line_hat, ...
                                                line_lenth, insideVec, obst_cent)
    global grid_x grid_y
    global dtheta
    global s_hat0 s_hat_min s_hat_max
    global p_hat_min p_hat_max

    % Determine obstacle region (on the inside of the line). If you draw a
    % vector from any vertex on the line (vertex1 chosen arbitrarily) to a
    % location, the location is "inside" that line if the vector alligns at
    % all with the insideVec of the line (i.e., dot product is positive)
    dotMat = ((grid_x-vertex1(1)).*insideVec(1)) + ((grid_y-vertex1(2)).*insideVec(2));
    obstRegion = dotMat >= 0;

    % Determine no brake region
    % alpha is the magnitude (0 to 180) of the angle between the nominal
    % trajectory and the normal vector (insideVec) for the line. This is
    % used to determine in the line normal trajectory is within the angular
    % uncertainty of the vehicle.
    alpha = acosd(dot([s_hat0 0], insideVec)./(norm(s_hat0).*norm(insideVec)));
    noBrakeRegion = getNoBrakeRegion(insideVec, vertex1, vertex2, alpha);

    % Determine regions corresponding to minimum angle (this is equal to
    % nominal in the case of dtheta = 0). The last argument to
    % getNoTurnRegion is set to 'true' because the minimum angle is used to
    % determine the leftmost boundary of the no-turn region.
    [noRightTurnRegion_min, noLeftTurnRegion_min, ...
      noTurnBound_min, behindRegion_min] = ...
        getNoTurnRegion(insideVec, vertex1, vertex2, line_hat, s_hat_min, p_hat_min, true);

    % Maximum angle and possible peak are unnecessary if there is no
    % angular uncertainty
    if (dtheta > 0)
        % Determine no turn regions corresponding to maximum angle. The 
        % last argument to getNoTurnRegion is set to 'false' because the 
        % maximum angle is used to determine the rightmost boundary of the 
        % no-turn region.
        [noRightTurnRegion_max, noLeftTurnRegion_max, ...
         noTurnBound_max, behindRegion_max] = ...
                getNoTurnRegion(insideVec, vertex1, vertex2, line_hat, s_hat_max, p_hat_max, false);
        
        % Determine normal peak location (if it exists within angle limits)
        peak = getNormalPeak(insideVec, vertex1, vertex2, line_lenth, obst_cent, alpha);
    else
        % Dummy outputs
        noRightTurnRegion_max = 0;
        noLeftTurnRegion_max = 0;
        noTurnBound_max = 0;
        behindRegion_max = 0;
        peak = [];
    end
end

%%
% This function finds the no brake region for a line.
%
% RETURN:
%
% noBrakeRegion - Region where the vehicle can't brake to avoid the line
% using the most limiting (i.e., most normal) trajectory to the line within
% the angular bounds. Also includes the circular region about vertex1 where
% braking won't work (if there is angular uncertainty).
%
% INPUTS:
%
% insideVec - unit vector normal to the line and pointing toward the inside
% of the obstacle
%
% vertex1/2 - the two vertices [x,y] that form the line. v2 is CCW from v1
%
% alpha - angle (between 0 and 180) between nominal vehicle trajectory and
% line normal vec (insideVec)
function noBrakeRegion = getNoBrakeRegion(insideVec, vertex1, vertex2, alpha)

    global s_hat0 s_hat_min s_hat_max
    global p_hat_min p_hat_max
    global dtheta
    global grid_x grid_y
    global s_brake

    % If trajectory normal to line is in range, it is limiting. Otherwise,
    % use whichever angle (max or min) most closely allignes to the
    % insideVec
    if dtheta <= 0                     % Use nominal traj
        s_hat_traj = s_hat0;
        p_hat_traj = cross([s_hat_traj 0], [0 0 1]);
        p_hat_traj = p_hat_traj(1:2);
    elseif alpha <= dtheta             % Use normal traj (insideVec)
        s_hat_traj = insideVec(1:2);
        p_hat_traj = cross([s_hat_traj 0], [0 0 1]);
        p_hat_traj = p_hat_traj(1:2);
    elseif dot([s_hat_min 0], insideVec) >= ...
           dot([s_hat_max 0], insideVec)    % Use min traj
        s_hat_traj = s_hat_min;
        p_hat_traj = p_hat_min;
    else                                    % Use max traj                   
        s_hat_traj = s_hat_max;
        p_hat_traj = p_hat_max;
    end

    % Line has a shadow if inside vector has allignment with velocity.
    % Otherwise, the vehicle is either past to line already, or will hit a
    % different line of the obstacle first.
    if (dot([s_hat_traj, 0], insideVec) > 0)
        
        % Distance along velocity vector to line
        % Equal to ||<v1_to_v2> X <v1_to_grid>|| / ||<s_hat> X <v1_to_v2>||
        grid_s_brake = (((vertex2(1)-vertex1(1)).*(grid_y-vertex1(2))) - ((vertex2(2)-vertex1(2)).*(grid_x-vertex1(1))))/...
                  ((s_hat_traj(1).*(vertex2(2)-vertex1(2))) - (s_hat_traj(2).*(vertex2(1)-vertex1(1))));

        % Lateral distances to line vertices 
        % Equal to dot(<grid_to_vert>, <p_hat>)
        grid_p_brake_v1 = ((vertex1(1)-grid_x).*p_hat_traj(1)) + ((vertex1(2)-grid_y).*p_hat_traj(2));      
        grid_p_brake_v2 = ((vertex2(1)-grid_x).*p_hat_traj(1)) + ((vertex2(2)-grid_y).*p_hat_traj(2)); 

        % A point is within the lateral "scope" of the line if the lateral
        % distances to the two vertices have different signs (i.e., one is
        % to the left, one is to the right). Otherwise, the vehicle can
        % simply go straight to avoid the line.
        inLineWidth = sign(grid_p_brake_v1) ~= sign(grid_p_brake_v2);
        
        % No-brake region (neglecting corners)
        noBrakeRegion = (grid_s_brake > 0) & ...     % In front of line AND
                        inLineWidth & ...            % within lateral span of line AND
                        (grid_s_brake <= s_brake);   % not enough space to brake to a stop

        % If there is angular uncertainty, you have to consider the
        % vertices separately since a pie-shaped no-brake region forms
        % around them due to the uncertainty.
        if (dtheta > 0)
            
            % Angle between nominal trajectory and a line drawn from grid 
            % to vertex1 
            % Equal to acos(dot(<grid_to_v1>, <s_hat0>) / (||grid_to_v1|| * ||s_hat0||))
            alpha_v1 = acosd((((vertex1(1)-grid_x).*s_hat0(1)) + ((vertex1(2)-grid_y).*s_hat0(2)))./ ...
                              (sqrt(((vertex1(1)-grid_x).^2)+((vertex1(2)-grid_y).^2)).*norm(s_hat0)));

            % Absolute distance to vertex 1 (used to fill in corners of shadow)
            grid_r_v1 = sqrt(((grid_x-vertex1(1)).^2) + ((grid_y-vertex1(2)).^2));

            % Include corner region              
            noBrakeRegion = noBrakeRegion | ...
                          ((alpha_v1 <= dtheta) & ...   % Within angular limits AND
                           (grid_r_v1 <= s_brake));     % Not enough space to brake to a stop
        end
    else
        noBrakeRegion = false(size(grid_x));        % Line doesn't have a brake shadow
    end
end

%%
% This function finds the no turn regions for a line and a given trajectory
%
% RETURN:
%
% noRightTurnRegion - Region where the vehicle cannot avoid both vertices 
% of the line by making a right turn.
%
% noLeftTurnRegion - Region where the vehicle cannot avoid both vertices 
% of the line by making a left turn.
%
% noTurnBoundRegion - Region used to form the bounding noTurn region. Will
% be similar to noRightTurnRegion or noLeftTurnRegion, depending on the
% value of leftBound.
%
% behindRegion - Region that exists behind the obstacle line from the
% perspective of the vehicle. This is used to modify the bounding regions 
% when dtheta < 90 to ensure areas behind the obstacle are not included in 
% the no turn region.
%
% INPUTS:
%
% insideVec - unit vector normal to the line and pointing toward the inside
% of the obstacle
%
% vertex1/2 - the two vertices [x,y] that form the line. v2 is CCW from v1.
%
% line_hat - unit vector from vertex1 to vertex2
%
% s_hat - vehicle trajectory unit vector
%
% p_hat - vehicle lateral unit vector (right turn)
%
% leftBound - If true, noTurnBoundRegion is calculated assuming a left turn
% is limiting for the given angle. If false, a right turn is assumed.
function [noRightTurnRegion, noLeftTurnRegion, noTurnBoundRegion, behindRegion] ...
               = getNoTurnRegion(insideVec, vertex1, vertex2, line_hat, s_hat, p_hat, leftBound)
    global dtheta
    global grid_x grid_y
    global v0 f g tau
    
    % Initialize the 4 output matrices
    noRightTurnRegion = false(size(grid_x));
    noLeftTurnRegion = false(size(grid_x));
    if (dtheta > 0)
        noTurnBoundRegion = false(size(grid_x));
        behindRegion = false(size(grid_x));
    else
        noTurnBoundRegion = 0;   % These aren't needed if there's no angular uncertainty
        behindRegion = 0;
    end
    
    % Distance along velocity vector to line
    % Equal to ||<v1_to_v2> X <v1_to_grid>|| / ||<s_hat> X <v1_to_v2>||
    grid_s = (((vertex2(1)-vertex1(1)).*(grid_y-vertex1(2))) - ((vertex2(2)-vertex1(2)).*(grid_x-vertex1(1))))/...
              ((s_hat(1).*(vertex2(2)-vertex1(2))) - (s_hat(2).*(vertex2(1)-vertex1(1))));

    % Distance along velocity vector to vertices
    % Equal to dot(<grid_to_vert>, <s_hat>)
    grid_s_v1 = ((vertex1(1)-grid_x).*s_hat(1)) + ((vertex1(2)-grid_y).*s_hat(2));   
    grid_s_v2 = ((vertex2(1)-grid_x).*s_hat(1)) + ((vertex2(2)-grid_y).*s_hat(2)); 

    % Distance normal to velocity vector (to the right) to vertices 
    % Equal to dot(<grid_to_vert>, <p_hat>)
    grid_p_v1 = ((vertex1(1)-grid_x).*p_hat(1)) + ((vertex1(2)-grid_y).*p_hat(2)); 
    grid_p_v2 = ((vertex2(1)-grid_x).*p_hat(1)) + ((vertex2(2)-grid_y).*p_hat(2));

    % Line has a shadow if inside vec alligns with trajectory
    if dot([s_hat, 0], insideVec) > 0
        
        % Bounding region stuff not necessary when there is no angular
        % uncertainty
        if (dtheta > 0)
            % Determine lateral direction used in bounding region left or
            % right)
            if leftBound
                grid_p_v1_bound = -grid_p_v1;
                grid_p_v2_bound = -grid_p_v2;
            else
                grid_p_v1_bound = grid_p_v1;
                grid_p_v2_bound = grid_p_v2;
            end

            % Get bounding region. Bounding region doesn't check for being 
            % in front of the line like the similar peak regions (below)
            % do. After a lot of testing, I found that the logical matrix
            % operations result in some wierd shapes when you use the same
            % logic on the bounding regions that are used in the peak
            % regions. Trial and error showed that removing that criteria
            % at this stage and then removing the regions that are behind
            % the obstacle at a later stage in the assembly of the region
            % results in the correct shapes.
            noTurnBoundRegion = getGeneralNoTurnRegion(grid_s_v1, grid_p_v1_bound, grid_s_v2, grid_p_v2_bound); 
        end
        
        % Right and left regions combine general algorithm with the
        % requirement that the space be in front of the line
        noRightTurnRegion = (grid_s > 0) & getGeneralNoTurnRegion(grid_s_v1, grid_p_v1, grid_s_v2, grid_p_v2);
        noLeftTurnRegion = (grid_s > 0) & getGeneralNoTurnRegion(grid_s_v1, -grid_p_v1, grid_s_v2, -grid_p_v2);  % Lateral matrices are flipped!

        % Check turn condition for bumping edges
        % There are two ways to detect that a vehicle will collide with an
        % obstacle: 
        % (1) show that the vehicle will not be able to clear an
        % obstacle vertex laterally before reaching it axially (i.e.,
        % consider only the vertices). Regions where this would occur are
        % determined in the steps performed above.
        % (2) show that even though the vehicle can clear all the vertices
        % of the obstacle, it would theoretically have to cross the edge of
        % the obstacle and then back over again before clearing the vertex
        % (meaning it would crash). This condition is more specialized and
        % not expected to be as important (it is neglected in the
        % getPolarSweep() code. However, it is accounted for here. This
        % method relies on the fact that in order for this to occur, the
        % trajectory of the vehicle must become parallel to the line within
        % the "lateral scope" of the line.
        
        % First determine the angle between the vehicle trajectory and the
        % line unit vector (i.e., the angle the vehicle must turn to become
        % parallel with the line)
        line_theta = acos(dot(s_hat, line_hat)./(norm(s_hat).*norm(line_hat)));
        
        % Since velocity in s direction is v0, and velocity in p direction
        % is f*g*T (where T is the time spent accelerating), then
        % tan[line_theta] = (f*g*T_tan)/v0, where T_tan is the lateral
        % acceleration time required to become parallel to the line.
        % Calculate T_tan:
        T_tan = (v0.*abs(tan(line_theta)))./(f.*g);
        
        % p_tan is the lateral distance traveled in the time it took to
        % become parallel to the line
        p_tan = (1./2).*f.*g.*(T_tan.^2);
        
        % s_tan is the net axial distance traveling in the time it took to
        % become parallel to the line (i.e., how much closer to the object
        % is the vehicle along its original trajectory than it was when it
        % start turning). This takes into account that the line is sloping
        % away from the vehicle as it turns.
        s_tan = (v0.*(T_tan + tau)) - (p_tan./abs(tan(line_theta)));
        
        % For a given line, this condition can only occur with either a
        % right or left turn. If the right turn vector is traveling away
        % from the object, then the condition is posible for a right turn.
        % If the opposive is true, the left turn. If the dot product below
        % is 0, then the vehicle is traveling perpendicular to the line.
        % With the vehicle model used, the vehicle can never become
        % parallel to the line with this initial trajectory, so the
        % condition is impossible.
        turnOrient = dot([p_hat, 0], -insideVec);
        if turnOrient > 0        % Right turn may bump into line in parallel
            
            bumpRegion = getGeneralNoTurnRegion_par(grid_s, grid_p_v1, grid_p_v2, s_tan, p_tan);
            
            % Add to noRightTurnRegion
            noRightTurnRegion = noRightTurnRegion | bumpRegion;
            
           % If there is angular uncertainty, and if the right turn is
           % considered the bounding direction, add to noTurnBoundRegion
           if (dtheta > 0) && (~leftBound)
               noTurnBoundRegion = noTurnBoundRegion | bumpRegion;
           end
        elseif turnOrient < 0    % Left turn may bump into line in parallel
            
            bumpRegion = getGeneralNoTurnRegion_par(grid_s, -grid_p_v1, -grid_p_v2, s_tan, p_tan);
            
            % Add to noLeftTurnRegion
            noLeftTurnRegion = noLeftTurnRegion | bumpRegion;
              
           % If there is angular uncertainty, and if the left turn is
           % considered the bounding direction, add to noTurnBoundRegion
           if (dtheta > 0) && leftBound
               noTurnBoundRegion = noTurnBoundRegion | bumpRegion;
           end
        end
        
    % If there is angular uncertainty and it is less than or equal to 90
    % degrees, calculate the region immediately behind the line. This
    % region is removed from the bounding no-turn region later. Which the
    % uncertainty is greater than 90, trial and error has shown that this
    % step is unnecessary and leads to wierd results.
    elseif (dtheta > 0) && (dtheta <= 90)
        
        % Region where axial distance is less than 0 and later scope is
        % within vertices.
        behindRegion = (grid_s < 0) & (sign(grid_p_v1) ~= sign(grid_p_v2));
    end   
end

%%
% This function implements the general algorithm for determining the region
% where a turn in a particular direction cannot be made without hitting one
% of the two vertices of a line.
%
% RETURN:
%
% noTurnRegion - Logical matrix representing a general no turn region for a
% certain line in a certain direction.
%
% INPUTS:
%
% grid_s_v1/2 - axial distance to vertex 1/2
%
% grid_p_v1/2 - lateral distance to vertex 1/2
function noTurnRegion = getGeneralNoTurnRegion(grid_s_v1, grid_p_v1, grid_s_v2, grid_p_v2)
    global v0 f g tau
    
    % This method of determining the no-turn region for a specific vertex
    % in a specific direction (i.e., right or left turn) enforces 2
    % requirements. Locations on the grid that meet both of these 
    % requirements for at least one of the two vertices is included in the
    % no-turn region.
    % (1) A location on the grid is a positive lateral distance away from
    % the vertex (positive in this context mean in the direction of the
    % desired turn). For instance, if the function is determining the
    % noRightTurnRegion, a point that has a vertex to the right of it would
    % have a positive lateral distance (i.e., it has to make a right turn
    % to clear the vertex).
    % (2) A location on the grid does not have enough axial distance in
    % front of the vertex to clear the remaining lateral distance.
    
    % Note that this function does not account for hitting the edge at a
    % parallel trajectory. That is done in getGeneralNoTurnRegion_par(). Is
    % also doesn't enforce the requirement that the initial location is in
    % front of the object. This is done in the calling function since in
    % some cases you don't want to do that.
    
    % Region that cannot clear vertex 1 in the desired direction
    noTurnRegion_v1 = (grid_p_v1 >= 0) & ...                                            % Must travel some lateral distance to clear vertex AND
                      (grid_s_v1 <= ((v0.*sqrt((4.*grid_p_v1)./(f.*g))) + (v0.*tau)));  % Not enough axial space to make turn
                  
    % Region that cannot clear vertex 2 in the desired direction
    noTurnRegion_v2 = (grid_p_v2 >= 0) & ...                                            % Must travel some lateral distance to clear vertex AND
                      (grid_s_v2 <= ((v0.*sqrt((4.*grid_p_v2)./(f.*g))) + (v0.*tau)));  % Not eonugh axial space to make turn
                  
    % Cannot clear vertex1 OR cannot clear vertex2 (either way you hit the
    % obstacle)
    noTurnRegion = noTurnRegion_v1 | noTurnRegion_v2;
end

%%
% This function implements the general algorithm for determining the region
% where a turn in a particular direction cannot be made without hitting the
% line at the parallel point in the turn.
%
% RETURN:
%
% noTurnRegion - Logical matrix representing a general parallel no turn 
% region for a certain line.
%
% INPUTS:
%
% grid_s - Axial distance to the line (matrix)
%
% grid_p_v1/2 - lateral distance to vertex 1/2 (matrix)
%
% s_tan - Net axial distance traveled to point where trajectory is parallel (single value)
%
% p_tan - Lateral distance traveled to point where trajectory is parallel (single value)
function noTurnRegion = getGeneralNoTurnRegion_par(grid_s, grid_p_v1, grid_p_v2, s_tan, p_tan)
    % The condition where the vehicle crashes into the line (but possibly
    % still clears the vertices) is evaluated by considering the point
    % where the vehicle has become parallel to the line during its lateral
    % manuever. This is the only point you care about in the turn because
    % in order to hit the line while still clearing the vertices, the
    % vehicle has to cross the line twice (once into the obstacle, and once
    % out). In order for that to occur, the trajectory must at some point
    % become parallel to the line. By considering the point in time in
    % which the vehicle is parallel to the line, we can see if it's inside
    % the vehicle at this point. If it is, then the vehicle obviously
    % crashed.

    noTurnRegion = (grid_s > 0) & ...                           % Vehicle is in front of line AND
                   (grid_s <= s_tan) & ...                      % the vehicle will be across the line (assuming it's an infinite line) at the parallel point AND
                   (min(grid_p_v1, grid_p_v2) <= p_tan) & ...   % the vehile will be within the lateral scope of the line when it becomes parallel
                   (max(grid_p_v1, grid_p_v2) >= p_tan);
end

%%
% This function determines if the trajectory normal to a line is within
% angle limits, and if so, provides the polar coordinates of the peak
% location of the no turn region relative of the obstacle center. The
% locations are saved so that the peaks can be linearly interpolated to
% create the rotated no turn region.
%
% RETURN:
%
% peak - location of normal line peak (if within angular limits) in polar
% coords relative to obstacle centroid. If peak not within bounds, this is
% empty [].
%
% INPUTS:
%
% insideVec - unit vector normal to the line and pointing toward the inside
% of the obstacle
%
% vertex1/2 - the two vertices [x,y] that form the line. v2 is CCW from v1.
%
% line_length - length of obstacle line
%
% obst_cent - centroid [x,y] of obstacle
%
% alpha - angle (0 to 180) between the nominal vehicle trajectory and the
% line normal (insideVec)
function peak = getNormalPeak(insideVec, vertex1, vertex2, line_length, obst_cent, alpha)
    global dtheta
    global v0 f g tau
    
    % The normal trajectory is within the range
    if alpha <= dtheta
        
        % Calculate peak location
        % When a trajectory is normal to a line, the two parabolas defining
        % the no turn region are symmetric. This means the lateral distance
        % associated with the peak is equal to half the length of the line.
        % Plugging this in to the general parabola equation gives:
        s_peak = v0.*(sqrt((2.*line_length)./(f.*g))+tau);
        
        % The peak location is found by starting at the midpoint of the
        % line and traveling a distance of s_peak away from the line.
        peak_point = mean([vertex1; vertex2]) + (s_peak.*(-insideVec(1:2)));
        
        % Save angle and radius relative to obst center
        cent_to_peak = peak_point - obst_cent;
        peak = [atan2d(cent_to_peak(2), cent_to_peak(1)), norm(cent_to_peak)];
    else
        % Normal trajectory is not within range
        peak = [];
    end 
end

%%
% This function takes previously generated regions and combines them to
% create a complete no turn region for an obstacle.
%
% RETURNS
%
% noTurnRegion - The assembled noTurnRegion for an obstacle when angular
% uncertainty is present
%
% INPUTS
%
% noRightTurnRegion_min - Region where the vehicle, at its minimum
% trajectory, cannot avoid the obstacle by turning right
%
% noRightTurnRegion_max - Region where the vehicle, at its maximum
% trajectory, cannot avoid the obstacle by turning right
%
% noLeftTurnRegion_min - Region where the vehicle, at its minimum
% trajectory, cannot avoid the obstacle by turning left
%
% noLeftTurnRegion_max - Region where the vehicle, at its maximum
% trajectory, cannot avoid the obstacle by turning left
%
% noTurnBoundRegion_min - Region forming minimum angle boundary for the
% obstacle
%
% noTurnBoundRegion_max - Region forming maximum angle boundary for the
% obstacle
%
% behindRegion_min - Region that exists behind the obstacle for the 
% minimum trajectory (if dtheta > 90 this is all false).
%
% behindRegion_max - Region that exists behind the obstacle for the 
% maximum trajectory (if dtheta > 90 this is all false).
%
% obst_cent - Centroid of obstracle
%
% turn_peaks - a (rx2) matrix, where each row provides a peak of the
% no-turn region in polar coordinates relative to the obstacle center. When
% input to this function, this only contains the peaks that are normal to
% an obstacle edge.
function [noTurnRegion] = assembleNoTurnRegion(noRightTurnRegion_min, noRightTurnRegion_max, ...
                                             noLeftTurnRegion_min, noLeftTurnRegion_max, ...
                                             noTurnBoundRegion_min, noTurnBoundRegion_max, ...
                                             behindRegion_min, behindRegion_max, ...
                                             obst_cent, turn_peaks)
    global dtheta
    global grid_x grid_y
               
    % The first task of this function is to complete turn_peaks by
    % converting the single-angle results at the minimum and maximum
    % trajectories into peaks.
    
    % Single angle no turn regions corresponding to min and max limits
    noTurn_peak_min = noRightTurnRegion_min & noLeftTurnRegion_min;
    noTurn_peak_max = noRightTurnRegion_max & noLeftTurnRegion_max;
    
    % Create polar coordinate system relative to obstacle center
    r_obst_cent_mat = sqrt(((grid_x-obst_cent(1)).^2) + ((grid_y-obst_cent(2)).^2));
    theta_obst_cent_mat = atan2d(grid_y-obst_cent(2), grid_x-obst_cent(1));
    
    % Find peak of minimum single angle region and add to saved peaks
    %
    % This line takes the grid nodes that are within the single-angle
    % no-turn region and calculates their distance from the obstacle
    % centroid. It then finds that index of the point that is farthest
    % (i.e., the peak).
    [~, peak_ind_min] = max(reshape(noTurn_peak_min.*r_obst_cent_mat, [], 1));
    
    % Extract the coordinates of the peak, convert to polar, and add to list
    peak_min = [grid_x(peak_ind_min) grid_y(peak_ind_min)];
    cent_to_peak_min = peak_min - obst_cent;
    turn_peaks = [turn_peaks; atan2d(cent_to_peak_min(2), cent_to_peak_min(1)), norm(cent_to_peak_min)];
    
    % Find peak of maximum single angle region and add to saved peaks
    %
    % This line takes the grid nodes that are within the single-angle
    % no-turn region and calculates their distance from the obstacle
    % centroid. It then finds that index of the point that is farthest
    % (i.e., the peak).
    [~, peak_ind_max] = max(reshape(noTurn_peak_max.*r_obst_cent_mat, [], 1));
    
    % Extract the coordinates of the peak, convert to polar, and add to list
    peak_max = [grid_x(peak_ind_max) grid_y(peak_ind_max)];
    cent_to_peak_max = peak_max - obst_cent;
    turn_peaks = [turn_peaks; atan2d(cent_to_peak_max(2), cent_to_peak_max(1)), norm(cent_to_peak_max)];
    
    % Sort peaks and ensure full range is covered in interpolation data.
    % This list of peaks doesn't need to worry about the minimum and
    % maximum angles, since the bounding region will form this boundary.
    % These peaks will only form the radial boundary of the region.
    turn_peaks = sortrows(turn_peaks);
    if min(turn_peaks(:,1)) > -180
        turn_peaks = [-180 turn_peaks(end,2); turn_peaks];
    end
    if max(turn_peaks(:,1)) < 180
        turn_peaks = [180 max(turn_peaks(1,2)); turn_peaks];
    end
    
    % Remove any duplicate rows (may occur if the minimum or maximum angle
    % also corresponds to an edge normal
    turn_peaks = unique(round(turn_peaks, 5), 'rows');
    
    % Combine bounding regions. The method of doing this changes when
    % dtheta is greater than 90 because the regions can start to merge on
    % the backside of the object. Trial and error has shown that this
    % method gives the expected shapes.
    if dtheta <= 90
        noTurnBoundRegion = noTurnBoundRegion_min & noTurnBoundRegion_max;  % AND the regions when total angle scope is < 180 deg
    else 
        noTurnBoundRegion = noTurnBoundRegion_min | noTurnBoundRegion_max;  % OR the regions when the total angle scope is > 180 deg
    end
    
    % Create complete no turn region
    noTurnRegion = noTurnBoundRegion & ...                 % Within bounding region (lateral boundaries) AND
         (~(behindRegion_min & behindRegion_max)) & ...    % not always behind obstacle AND
         (r_obst_cent_mat <= interp1(turn_peaks(:,1), ...  % radius falls within saved peaks (linear polar sweep to form radial boundary)
         turn_peaks(:,2), theta_obst_cent_mat));
end
